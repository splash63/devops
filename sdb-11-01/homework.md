# Домашнее задание к занятию "`Базы данных, их типы`

## Задание 1

1.1. Бюджетирование проектов и финансовые отчёты
Тип СУБД: реляционная (например, PostgreSQL).

Реляционные СУБД обеспечивают строгую структуру данных и целостность, что критично для финансовых операций.

Поддерживают транзакции (ACID-совместимость), что важно для бюджетирования и отчётности.

Позволяют выполнять сложные SQL-запросы для аналитики и прогнозирования рисков.

Имеют расширенные возможности для работы с финансовыми данными, включая поддержку временных рядов, партиционирования и параллельных запросов.
Ускорение хеширования: если хеширование занимает много времени, можно использовать специализированные алгоритмы или библиотеки, например OpenSSL, которая оптимизирована для быстрой работы с хешами. Также можно рассмотреть использование in-memory СУБД (например, Redis) для кэширования результатов хеширования, чтобы снизить нагрузку на основную СУБД.

1.1.* Ускорение хеширования: если хеширование занимает много времени, можно использовать специализированные алгоритмы или библиотеки, например OpenSSL, которая оптимизирована для быстрой работы с хешами. Также можно рассмотреть использование in-memory СУБД (например, Redis) для кэширования результатов хеширования, чтобы снизить нагрузку на основную СУБД.

1.2. Для лендингов: NoSQL (например, MongoDB).

Лендинги часто работают с неструктурированными или полуструктурированными данными (контент, формы обратной связи), что подходит для документоориентированных СУБД.

Гибкость схемы позволяет быстро адаптировать лендинги под новые требования без изменения структуры базы данных.
Для CRM: реляционная СУБД (например, PostgreSQL).

CRM-системы часто требуют сложных транзакций, аналитики и отчётности, что лучше реализуется в реляционных СУБД.
Поддержка SQL упрощает интеграцию с инструментами бизнес-аналитики и отчётности.

1.2.* Можно использовать одну СУБД, например, MongoDB может использоваться и для лендингов, и для CRM, если готова работать с гибкой схемой. Однако для CRM может потребоваться доработка схемы и логики, чтобы обеспечить все необходимые функции (например, сложные связи между данными, транзакции). В некоторых случаях эффективнее использовать две СУБД: NoSQL для лендингов и реляционную для CRM, чтобы оптимально решить задачи каждой системы.

1.3. Тип СУБД: реляционная (например, PostgreSQL).

Простая и понятная структура реляционных СУБД подходит для хранения структурированных данных с чёткой иерархией (нормы, правила, обучающие материалы).
Легко реализовать связи между различными разделами базы данных (например, между отделами и их специфическими нормами).

1.3.* Использование существующей СУБД: можно использовать ту же реляционную СУБД, что и для бюджетирования (например, PostgreSQL). Это упростит интеграцию данных и снизит затраты на поддержку нескольких систем.

1.4. Тип СУБД: графовая (например, Neo4j).

Графовые СУБД оптимизированы для работы со сложными связями между объектами (маршруты, курьеры, материалы), что критично для задач логистики.
Позволяют быстро выполнять запросы на поиск оптимальных маршрутов и распределение ресурсов.

1.4.* Можно подключить отдел закупок к той же графовой СУБД, если требуется анализировать связи между закупками, поставщиками, материалами и логистикой. Однако если у отдела закупок есть уникальные требования к хранению и обработке данных, которые не пересекаются с задачами логистики, может быть разумным создать отдельную СУБД.

1.5.* Мультимодельная СУБД (например, ArangoDB).

ArangoDB поддерживает реляционную, графовую и ключ-значение модели данных, что позволяет решить все перечисленные задачи в одной системе.
Гибкость мультимодельных СУБД позволяет эффективно работать с разными типами данных и связями между ними.
Однако стоит учитывать, что использование единой СУБД для всех задач может усложнить архитектуру системы и потребовать более тщательной настройки. В некоторых случаях разделение на несколько специализированных СУБД может быть более эффективным с точки зрения производительности и удобства поддержки.

При выборе конкретной СУБД также стоит учитывать дополнительные факторы: бюджет, имеющуюся инфраструктуру, требования к масштабируемости, интеграцию с другими системами и навыки команды разработчиков.

## Задание 2

### 2.1

1. Валидация входных данных

Проверка корректности номера телефона в базе

Проверка формата введённой суммы

Проверка наличия номера в системе оператора

Верификация статуса номера (не заблокирован ли)

2. Создание записи транзакции

Формирование уникального ID операции

Занесение данных плательщика

Фиксация суммы пополнения

Запись времени начала операции

Сохранение способа оплаты

3. Проверка лимитов и ограничений

Проверка максимального размера пополнения

Контроль суточных лимитов

Анализ месячного оборота

Проверка на соответствие правилам антифрода

4. Обработка платежа

Запрос статуса платежа в платёжной системе

Получение подтверждения от банка/платёжного агрегатора

Запись статуса операции в базу данных

Блокировка суммы до завершения транзакции

5. Обновление баланса абонента

Корректировка баланса на указанную сумму

Обновление даты последнего пополнения

Запись операции в историю платежей абонента

Обновление статуса счёта

6. Фиксация итогов операции

Формирование записи об успешном завершении

Создание электронного чека

Отправка уведомлений в системы мониторинга

Архивация данных операции

Обновление статусов во всех связанных таблицах

Контроль целостности данных

Синхронизация с внешними системами

Формирование отчётности

Обновление кэшированных данных

## Задание 3

### 3.1

1. Транзакционная целостность

Поддержка ACID-свойств (атомарность, согласованность, изоляция, долговечность)

Гарантированная целостность данных при выполнении операций

Возможность отката транзакций в случае ошибок

Надежная работа с критически важными данными

2. Зрелая экосистема

Десятилетия развития и оптимизации

Широкая документация и обучающие материалы

Большое сообщество разработчиков

Множество инструментов для администрирования

Стабильные и проверенные решения

3. Структурированность данных

Строгая схема базы данных

Четко определенные типы данных

Контроль целостности на уровне БД

Простота понимания структуры

Легкость в поддержке и модификации

4. Мощный язык запросов

SQL как стандартизированный язык

Богатый набор операторов и функций

Возможность сложных аналитических запросов

Оптимизированный механизм выполнения

Высокая производительность при работе со сложными запросами

5. Масштабируемость вверх

Вертикальное масштабирование (увеличение мощности сервера)

Репликация для обеспечения отказоустойчивости

Резервное копирование и восстановление

Поддержка кластеризации

Возможность миграции на более мощное оборудование

## Задание 4

Ключевыми критериями становятся масштабируемость, производительность, распределённая обработка нагрузки, поддержка сложных вычислений и управление данными. Также важно учитывать требования к консистентности данных, тип данных (структурированные/неструктурированные) и специфику задач (OLTP, OLAP, машинное обучение и т. д.).
Наиболее подходящей моделью распределённых вычислений будет Apache Spark. Он позволяет максимально эффективно использовать ресурсы кластера за счёт in-memory вычислений и оптимизации запросов (например, с помощью Catalyst в Spark SQL). Spark поддерживает как пакетную обработку, так и потоковые данные, что гибко для разных сценариев.